---
title: "Construction Paths"
author: "Nina Peleg"
date: "2025-01-28"
output: html_document
---

# Libraries

```{r}
library(tidyverse)
library(progress)
library(igraph)
library(ggraph)
library(tidygraph)
```

This script is designed to process data from datavyu for construction coding of ALL MODELS by lots of participants as one long data file Load in data + make sure all onset/offset columns are integer

```{r}
data <- read.csv("data/adult_data2.csv")
data <- read.csv("data/child_data.csv")
convert_to_integer <- function(df) {
  for (col in names(df)) {
    if (grepl("offset|onset", col, ignore.case = TRUE)) {
      df[[col]] <- as.integer(as.character(df[[col]]))
    }
  }
  return(df)
}
data <- convert_to_integer(data)
data <- data %>%
  filter(ID_id != "BT_S011_AD")
```

Data needs to be reshaped in order to process moves.
1.
We split up moves where there are several relational blocks into different rows, so that we make sure to include all blocks when we're building states.

```{r}
duplicate_rows <- function(df, relation_cols) {
  # Identify columns with relation1 and values in corresponding relation columns
  relation1_cols <- grep("relation1", names(df), value = TRUE)
  relation_cols <- lapply(relation_cols, function(col) grep(col, names(df), value = TRUE))
  
  # Ensure the columns are paired correctly
  relation_pairs <- data.frame(relation1 = relation1_cols)
  for (i in seq_along(relation_cols)) {
    relation_pairs[paste0("relation", i + 1)] <- relation_cols[[i]]
  }
  
  # Function to duplicate rows based on a specific relation column
  duplicate_for_relation <- function(df, relation_pair) {
    rows_to_duplicate <- df %>% filter(rowSums(df[relation_pair] != "." & df[relation_pair] != "") > 0)
    duplicated_rows <- rows_to_duplicate
    for (i in 1:nrow(relation_pairs)) {
      duplicated_rows[[relation_pairs$relation1[i]]] <- rows_to_duplicate[[relation_pair[i]]]
    }
    return(duplicated_rows)
  }
  
  # Combine original and duplicated rows for each relation column
  duplicated_rows_list <- lapply(relation_cols, function(cols) duplicate_for_relation(df, cols))
  result <- bind_rows(df, do.call(bind_rows, duplicated_rows_list)) %>%
    arrange(ID_id, Task_model_type, Construct_Action_onset) %>%
    distinct()
  
  return(result)
}

# Apply the function to the data frame
relation_cols <- c("relation2", "relation3", "relation4")
data <- duplicate_rows(data, relation_cols)
```

2.  We need to make coding of moves into strings - but we also need to consider how the same moves would look from different perspectives. Then we'll get rid of all the helper columns, to be left with moves - strings related to it + orienting

```{r}
# Rename the first 7 columns
colnames(data)[12:18] <- c('b1', 'a_b', 'b1_v_h', 'b2', 'b2_v_h', 'f_b', 'l_r')

data$l_r <- as.numeric(data$l_r)
data$f_b <- as.numeric(data$f_b)



# Create the second set of 7 columns
data <- data %>%
  mutate(
    b1_2 = b1,
    a_b_2 = a_b,
    b1_v_h_2 = ifelse(b1_v_h == '.', '.', ifelse(b1_v_h == 'v', 'h', 'v')),
    b2_2 = b2,
    b2_v_h_2 = ifelse(b2_v_h == '.', '.', ifelse(b2_v_h == 'v', 'h', 'v')),
    f_b_2 = ifelse(is.na(l_r), NA, -l_r),
    l_r_2 = f_b
  )

# Create the third set of 7 columns
data <- data %>%
  mutate(
    b1_3 = b1,
    a_b_3 = a_b,
    b1_v_h_3 = b1_v_h,
    b2_3 = b2,
    b2_v_h_3 = b2_v_h,
    f_b_3 = ifelse(is.na(f_b), NA, -f_b),
    l_r_3 = ifelse(is.na(l_r), NA, -l_r)
  )

# Create the fourth set of 7 columns
data <- data %>%
  mutate(
    b1_4 = b1,
    a_b_4 = a_b,
    b1_v_h_4 = ifelse(b1_v_h == '.', '.', ifelse(b1_v_h == 'v', 'h', 'v')),
    b2_4 = b2,
    b2_v_h_4 = ifelse(b2_v_h == '.', '.', ifelse(b2_v_h == 'v', 'h', 'v')),
    f_b_4 = l_r,
    l_r_4 = ifelse(is.na(f_b), NA, -f_b)
  )

# create below 1 
data <- data %>%
  mutate(
    b1_b = b2,
    a_b_b = ifelse(a_b == "a", "b", ifelse(a_b == "b", "a", NA_character_)),
    b1_v_h_b = b2_v_h,
    b2_b = b1, 
    b2_v_h_b = b1_v_h,
    f_b_b = -f_b,
    l_r_b = -l_r
  )

# create below 2
data <- data %>%
  mutate(
    b1_b2 = b2_2,
    a_b_b2 = ifelse(a_b_2 == "a", "b", ifelse(a_b == "b", "a", NA_character_)),
    b1_v_h_b2 = b2_v_h_2,
    b2_b2 = b1_2, 
    b2_v_h_b2 = b1_v_h_2,
    f_b_b2 = -f_b_2,
    l_r_b2 = -l_r_2
  )
# create below 3
data <- data %>%
  mutate(
    b1_b3 = b2_3,
    a_b_b3 = ifelse(a_b_3 == "a", "b", ifelse(a_b == "b", "a", NA_character_)),
    b1_v_h_b3 = b2_v_h_3,
    b2_b3 = b1_3, 
    b2_v_h_b3 = b1_v_h_3,
    f_b_b3 = -f_b_3,
    l_r_b3 = -l_r_3
  )
# create below 4
data <- data %>%
  mutate(
    b1_b4 = b2_4,
    a_b_b4 = ifelse(a_b_4 == "a", "b", ifelse(a_b == "b", "a", NA_character_)),
    b1_v_h_b4 = b2_v_h_4,
    b2_b4 = b1_4, 
    b2_v_h_b4 = b1_v_h_4,
    f_b_b4 = -f_b_4,
    l_r_b4 = -l_r_4
  )

# Create the node columns
data <- data %>%
  mutate(
    view1 = paste(b1, a_b, b1_v_h, b2, b2_v_h, f_b, l_r, sep = "_"),
    view2 = paste(b1_2, a_b_2, b1_v_h_2, b2_2, b2_v_h_2, f_b_2, l_r_2, sep = "_"),
    view3 = paste(b1_3, a_b_3, b1_v_h_3, b2_3, b2_v_h_3, f_b_3, l_r_3, sep = "_"),
    view4 = paste(b1_4, a_b_4, b1_v_h_4, b2_4, b2_v_h_4, f_b_4, l_r_4, sep = "_"),
    below1 = paste(b1_b, a_b_b, b1_v_h_b, b2_b, b2_v_h_b, f_b_b, l_r_b, sep = "_"),
    below2 = paste(b1_b2, a_b_b2, b1_v_h_b2, b2_b2, b2_v_h_b2, f_b_b2, l_r_b2, sep = "_"),
    below3 = paste(b1_b3, a_b_b3, b1_v_h_b3, b2_b3, b2_v_h_b3, f_b_b3, l_r_b3, sep = "_"),
    below4 = paste(b1_b4, a_b_b4, b1_v_h_b4, b2_b4, b2_v_h_b4, f_b_b4, l_r_b4, sep = "_")
  )
data <- data %>%
  select(ID_id, Task_model_type, Task_correct_final_ci, Construct_Action_onset, Construct_Action_offset, Construct_Action_action_cd, Perspective_Orienting_onset, Perspective_Orienting_offset, Perspective_Orienting_direction_lr, view1, view2, view3, view4, below1, below2, below3, below4)
```

3.  Now we need to start thinking about the perspective orienting. When participants move model, the moves coding changes, we need to know which view they are in at any point

```{r}
# First we coalesce in the two onsets, so we can intermix in the persp_orienting and moves. Then make sure the rows are arranged correctly, then we want to create a column which keeps note of which moves are actually one move (what we split earlier). Lastly, we add Action_Number (ignoring one_move for now)
data <- data %>%
  mutate(Construct_Action_onset = coalesce(Construct_Action_onset, Perspective_Orienting_onset),
         Construct_Action_offset = coalesce(Construct_Action_offset, Perspective_Orienting_offset)) %>%
  select(-Perspective_Orienting_onset, -Perspective_Orienting_offset) %>%
  group_by(ID_id, Task_model_type) %>%
  arrange(ID_id, Task_model_type, Construct_Action_onset) %>%
  mutate(one_move = ifelse(
    lag(substr(view1, 1, 2)) == substr(view1, 1, 2) & lag(Construct_Action_offset) == Construct_Action_offset,
    TRUE,
    NA
  )) %>%
 mutate(Action_Number = ifelse(
    !is.na(Construct_Action_action_cd) & Construct_Action_action_cd != "",
    cumsum(!is.na(Construct_Action_action_cd) & Construct_Action_action_cd != ""),
    NA
  )) %>%
  fill(Action_Number, .direction = "down")
```

ADD IN STUFF ABOUT STARTING MODEL FROM SCRATCH?
but really it should just be coded correctly ....
extra column for extra moves out side the model?

4.  Now we want to initialize a view_counter column which tells us what view they are in (as compared to their original view). We also create a column that tells us what view the move was initially made in.

```{r}
# Initialize the view counter column
data <- data %>%
  group_by(ID_id, Task_model_type) %>%
  mutate(view_counter = 1) %>%
  mutate(view_counter = ifelse(Action_Number == 1 | Perspective_Orienting_direction_lr == ".", 1, view_counter))

# Function to update view_counter based on Perspective_Orienting_direction_lr
update_view_counter <- function(df) {
  for (i in 2:nrow(df)) {
    if (df$ID_id[i] == df$ID_id[i-1]) {  # Check if the current and previous rows have the same ID
      if (df$Perspective_Orienting_direction_lr[i] == "c") {  # Center direction
        df$view_counter[i] <- df$view_counter[i-1] + 1
        if (df$view_counter[i] > 4) df$view_counter[i] <- 1  # Reset if exceeds 4
      } else if (df$Perspective_Orienting_direction_lr[i] == "a") {  # Anti-clockwise direction
        df$view_counter[i] <- df$view_counter[i-1] - 1
        if (df$view_counter[i] < 1) df$view_counter[i] <- 4  # Reset if below 1
      } else if (df$Perspective_Orienting_direction_lr[i] == "") {  # No change in direction
        df$view_counter[i] <- df$view_counter[i-1]
      } else if (df$Perspective_Orienting_direction_lr[i] == ".") {  # Reset to 1
        df$view_counter[i] <- 1
      }
    }
  }
  return(df)
}

# Apply the function to update view_counter
data <- data %>%
  group_by(ID_id, Task_model_type) %>%
  do(update_view_counter(.))%>%
 filter(Construct_Action_action_cd != "")
data$view_move <- data$view_counter 
```

5.  We now convert the data into a much longer df, where every move is repeated with new moves, this makes it easier to keep track of constructs and deconstructs in a concatenated_moves list

```{r}
process_data <- function(df) {
  # Initialize a list to store the results for each Task_model_type
  results <- list()
  
  # Loop through each Task_model_type from 'm1' to 'm8'
  for (model_type in paste0('m', 1:8)) {
    # Filter the dataframe for the current Task_model_type
    df_filtered <- df %>% filter(Task_model_type == model_type)
    
    # Initialize an empty dataframe to store the results for the current model type
    result <- data.frame()
    
    # Loop through each participant
    participants <- unique(df_filtered$ID_id)
    for (participant in participants) {
      df_participant <- df_filtered %>% filter(ID_id == participant)
      
      # Loop through each action number
      for (i in 1:nrow(df_participant)) {
        current_row <- df_participant[i, ]
        new_rows <- df_participant[1:i, ]
        
        # Update Action_Number and view_counter for previous actions
        new_rows$Action_Number <- current_row$Action_Number
        new_rows$view_counter <- current_row$view_counter
        
        # Add move_number column
        new_rows$move_number <- 1:i
        
        # Append to the result dataframe
        result <- bind_rows(result, new_rows)
      }
    }
    
    # Store the result dataframe in the list with the model type as the name
    results[[model_type]] <- result
  }
  
  return(results)
}

# Run the function
data_moves_list <- process_data(data)

```

6.  We can also make a new column called string, which tells us which string to focus on for addition to moves. (not sure we need this)

```{r}
compute_string_choice <- function(df) {
  df <- df %>%
    mutate(string_choice = ifelse(Action_Number == move_number, 
                                  1, 
                                  (1 + (view_counter - view_move) - 1) %% 4 + 1),
           string = case_when(
             string_choice == 1 ~ view1,
             string_choice == 2 ~ view2,
             string_choice == 3 ~ view3,
             string_choice == 4 ~ view4
           ))
  return(df)
}

# Apply the function to all dataframes in the list
data_moves_list <- lapply(data_moves_list, compute_string_choice)
```

7.  This function concatenates the moves within every move (i.e. at move 5 it concatenates moves 1-5), giving us a string of what moves are currently included in the model

```{r}
create_concatenated_moves <- function(df) {
  # Initialize the progress bar
  pb <- progress_bar$new(
    format = "  Processing [:bar] :percent in :elapsed",
    total = nrow(df),
    clear = FALSE,
    width = 60
  )
  
  # Initialize an empty column for concatenated_moves
  df$concatenated_moves <- ""
  
  # Loop through each participant and action number
  participants <- unique(df$ID_id)
  for (participant in participants) {
    df_participant <- df %>% filter(ID_id == participant)
    action_numbers <- unique(df_participant$Action_Number)
    
    for (action_number in action_numbers) {
      df_action <- df_participant %>% filter(Action_Number == action_number)
      concatenated_moves <- ""
      
      for (i in 1:nrow(df_action)) {
        current_row <- df_action[i, ]
        
        if (current_row$Construct_Action_action_cd == "c") {
          concatenated_moves <- paste0(concatenated_moves, ifelse(concatenated_moves == "", "", ", "), current_row$string)
        } else if (current_row$Construct_Action_action_cd %in% c("d", "f")) {
          # Check and remove strings from concatenated_moves
          for (j in 1:4) {
            view_col <- paste0("view", j)
            below_col <- paste0("below", j)
            if (current_row[[view_col]] %in% strsplit(concatenated_moves, ", ")[[1]]) {
              concatenated_moves <- gsub(paste0(", ", current_row[[view_col]]), "", concatenated_moves)
              concatenated_moves <- gsub(current_row[[view_col]], "", concatenated_moves)
            }
            if (current_row[[below_col]] %in% strsplit(concatenated_moves, ", ")[[1]]) {
              concatenated_moves <- gsub(paste0(", ", current_row[[below_col]]), "", concatenated_moves)
              concatenated_moves <- gsub(current_row[[below_col]], "", concatenated_moves)
            }
          }
        }
        
        # Update the concatenated_moves column
        df$concatenated_moves[df$ID_id == participant & df$Action_Number == action_number] <- concatenated_moves
        
        # Update the progress bar
        pb$tick()
      }
    }
  }
  
  return(df)
}

# Apply the function to all dataframes in the list
data_moves_list <- lapply(data_moves_list, create_concatenated_moves)

# Filter each dataframe to keep only the last row for each ID_id and Action_Number
data_moves_list <- lapply(data_moves_list, function(df) {
  df %>%
    group_by(ID_id, Action_Number) %>%
    filter(row_number() == n()) %>%
    ungroup()
})
```

8.  Now we want to get rid again of the moves we've split up - i.e. put them into one move again. We should decide whether to get rid of rows in between or keep them there so we know what's happening in between - here we've kept them.. We also need to put together contiguous moves (moves that were done together but coded one frame apart)

```{r}
transform_df <- function(df) {
  df %>%
    group_by(ID_id) %>%
    mutate(New_Action_Number = cumsum(
      is.na(lag(Construct_Action_action_cd)) | 
      is.na(lag(Construct_Action_offset)) | 
      Construct_Action_action_cd != lag(Construct_Action_action_cd) | 
      abs(Construct_Action_offset - lag(Construct_Action_offset)) >= 200 | 
      row_number() == 1
    )) %>%
    ungroup()
}
# Apply the function to each dataframe in the list
data_moves_list <- lapply(data_moves_list, transform_df)

```

9.  Next we create a set of dfs which give us all the moves that have been included by all participants in each model. We then number these so we can start dealing with numbered states (rather than strings)

```{r}
# Define the function to create the lookup table
create_lookup_table <- function(df) {
  unique_strings <- c()
  
  is_unique <- function(row) {
    for (value in row) {
      if (value %in% unique_strings) {
        return(FALSE)
      }
    }
    unique_strings <<- unique(c(unique_strings, row))
    return(TRUE)
  }
  
  look_up <- df %>%
    ungroup() %>%
    select(view1, view2, view3, view4, below1, below2, below3, below4) %>%
    rowwise() %>%
    filter(is_unique(c_across(everything()))) %>%
    ungroup() %>%
    mutate(move_ID = row_number())
  
  return(look_up)
}

# Apply the function to each data frame in the list
create_lookup_tables_for_list <- function(data_moves_list) {
  lookup_tables <- lapply(data_moves_list, create_lookup_table)
  names(lookup_tables) <- names(data_moves_list)
  return(lookup_tables)
}

lookup_tables <- create_lookup_tables_for_list(data_moves_list)
```

10. Bring in correct moves, there are 5 base correct moves but they can be labelled 8 ways each. so we have to convert to all views like we did originally.

```{r}
correct_moves <- read.csv("data/correct_moves_compact.csv")

# Create the second set of 7 columns
correct_moves <- correct_moves %>%
  mutate(
    b1_2 = b1,
    a_b_2 = a_b,
    b1_v_h_2 = ifelse(b1_v_h == '.', '.', ifelse(b1_v_h == 'v', 'h', 'v')),
    b2_2 = b2,
    b2_v_h_2 = ifelse(b2_v_h == '.', '.', ifelse(b2_v_h == 'v', 'h', 'v')),
    f_b_2 = ifelse(is.na(l_r), NA, -l_r),
    l_r_2 = f_b
  )

# Create the third set of 7 columns
correct_moves <- correct_moves %>%
  mutate(
    b1_3 = b1,
    a_b_3 = a_b,
    b1_v_h_3 = b1_v_h,
    b2_3 = b2,
    b2_v_h_3 = b2_v_h,
    f_b_3 = ifelse(is.na(f_b), NA, -f_b),
    l_r_3 = ifelse(is.na(l_r), NA, -l_r)
  )

# Create the fourth set of 7 columns
correct_moves <- correct_moves %>%
  mutate(
    b1_4 = b1,
    a_b_4 = a_b,
    b1_v_h_4 = ifelse(b1_v_h == '.', '.', ifelse(b1_v_h == 'v', 'h', 'v')),
    b2_4 = b2,
    b2_v_h_4 = ifelse(b2_v_h == '.', '.', ifelse(b2_v_h == 'v', 'h', 'v')),
    f_b_4 = l_r,
    l_r_4 = ifelse(is.na(f_b), NA, -f_b)
  )

# create below 1 
correct_moves <- correct_moves %>%
  mutate(
    b1_b = b2,
    a_b_b = ifelse(a_b == "a", "b", ifelse(a_b == "b", "a", NA_character_)),
    b1_v_h_b = b2_v_h,
    b2_b = b1, 
    b2_v_h_b = b1_v_h,
    f_b_b = -f_b,
    l_r_b = -l_r
  )

# create below 2
correct_moves <- correct_moves %>%
  mutate(
    b1_b2 = b2_2,
    a_b_b2 = ifelse(a_b_2 == "a", "b", ifelse(a_b == "b", "a", NA_character_)),
    b1_v_h_b2 = b2_v_h_2,
    b2_b2 = b1_2, 
    b2_v_h_b2 = b1_v_h_2,
    f_b_b2 = -f_b_2,
    l_r_b2 = -l_r_2
  )
# create below 3
correct_moves <- correct_moves %>%
  mutate(
    b1_b3 = b2_3,
    a_b_b3 = ifelse(a_b_3 == "a", "b", ifelse(a_b == "b", "a", NA_character_)),
    b1_v_h_b3 = b2_v_h_3,
    b2_b3 = b1_3, 
    b2_v_h_b3 = b1_v_h_3,
    f_b_b3 = -f_b_3,
    l_r_b3 = -l_r_3
  )
# create below 4
correct_moves <- correct_moves %>%
  mutate(
    b1_b4 = b2_4,
    a_b_b4 = ifelse(a_b_4 == "a", "b", ifelse(a_b == "b", "a", NA_character_)),
    b1_v_h_b4 = b2_v_h_4,
    b2_b4 = b1_4, 
    b2_v_h_b4 = b1_v_h_4,
    f_b_b4 = -f_b_4,
    l_r_b4 = -l_r_4
  )

# Create the node columns
correct_moves <- correct_moves %>%
  mutate(
    view1 = paste(b1, a_b, b1_v_h, b2, b2_v_h, f_b, l_r, sep = "_"),
    view2 = paste(b1_2, a_b_2, b1_v_h_2, b2_2, b2_v_h_2, f_b_2, l_r_2, sep = "_"),
    view3 = paste(b1_3, a_b_3, b1_v_h_3, b2_3, b2_v_h_3, f_b_3, l_r_3, sep = "_"),
    view4 = paste(b1_4, a_b_4, b1_v_h_4, b2_4, b2_v_h_4, f_b_4, l_r_4, sep = "_"),
    below1 = paste(b1_b, a_b_b, b1_v_h_b, b2_b, b2_v_h_b, f_b_b, l_r_b, sep = "_"),
    below2 = paste(b1_b2, a_b_b2, b1_v_h_b2, b2_b2, b2_v_h_b2, f_b_b2, l_r_b2, sep = "_"),
    below3 = paste(b1_b3, a_b_b3, b1_v_h_b3, b2_b3, b2_v_h_b3, f_b_b3, l_r_b3, sep = "_"),
    below4 = paste(b1_b4, a_b_b4, b1_v_h_b4, b2_b4, b2_v_h_b4, f_b_b4, l_r_b4, sep = "_")
  )
correct_moves <- correct_moves %>%
  select(model, view1, view2, view3, view4, below1, below2, below3, below4)
correct_moves_list <- split(correct_moves, correct_moves$model)
```

11. Now we match up (numbered) moves made with correct moves. Creating a column called match which tells us if a numbered move that has been done is a correct move.

```{r}
# Function to check if any string in any column of a row is found in the corresponding correct_moves dataframe
check_match <- function(lookup_df, correct_df) {
  # Initialize match column
  lookup_df$match <- FALSE
  
  # Iterate over each row in lookup_df
  for (i in 1:nrow(lookup_df)) {
    row_values <- unlist(lookup_df[i, ])
    match_found <- FALSE
    
    # Check if any value in the row is found in the correct_df
    for (value in row_values) {
      if (any(value %in% unlist(correct_df))) {
        match_found <- TRUE
        break
      }
    }
    
    # Update the match column
    lookup_df$match[i] <- match_found
  }
  
  return(lookup_df)
}

# Apply the function to each pair of dataframes in the lists
for (i in 1:length(lookup_tables)) {
  lookup_tables[[i]] <- check_match(lookup_tables[[i]], correct_moves_list[[i]])
}

```

12. Now we convert concatenated_moves into strings of numbers (easier to use) and say whether all indicate correct move... this does not solve the problem of them being in the same view point

```{r}
# Function to find all move_IDs for concatenated_moves
find_move_ids <- function(concatenated_moves, lookup_long) {
  # Split concatenated_moves into individual strings
  moves <- unlist(strsplit(concatenated_moves, ", "))
  move_ids <- c()
  
  # Iterate over each string in moves
  for (move in moves) {
    # Check if the move is found in any row and any column of lookup_long
    found_ids <- lookup_long %>%
      filter(apply(lookup_long, 1, function(row) any(row == move))) %>%
      pull(move_ID)
    
    move_ids <- c(move_ids, found_ids)
  }
  
  if (length(move_ids) > 0) {
    return(paste(unique(move_ids), collapse = ", "))
  } else {
    return(NA)
  }
}

# Function to apply the find_move_ids function to a single data frame
apply_find_move_ids <- function(df, lookup_long) {
  df %>%
    rowwise() %>%
    mutate(state = find_move_ids(concatenated_moves, lookup_long)) %>%
    ungroup()
}

# Apply the function to each pair of dataframes in the lists
for (i in 1:length(data_moves_list)) {
  data_moves_list[[i]] <- apply_find_move_ids(data_moves_list[[i]], lookup_tables[[i]])
}

# Replace NA values in state with 0
for (i in 1:length(data_moves_list)) {
  data_moves_list[[i]] <- data_moves_list[[i]] %>%
    mutate(state = ifelse(is.na(state), "0", state))
}


```

13. Lastly, we check if all numbered moves in state are correct and if so we make match TRUE, meaning the state is correct (this doesn't solve views issue)

```{r}
# Function to check if all move_IDs in state are associated with TRUE match in lookup_table
check_all_true_match <- function(state, lookup_long) {
  if (is.na(state) || state == "0") {
    return(FALSE)
  }
  
  move_ids <- unlist(strsplit(state, ", "))
  all_true <- all(sapply(move_ids, function(id) {
    any(lookup_long$move_ID == id & lookup_long$match == TRUE)
  }))
  
  return(all_true)
}

# Function to apply the check_all_true_match function to a single data frame
apply_check_all_true_match <- function(df, lookup_long) {
  df %>%
    rowwise() %>%
    mutate(match = check_all_true_match(state, lookup_long)) %>%
    ungroup()
}

# Apply the function to each pair of dataframes in the lists
for (i in 1:length(data_moves_list)) {
  data_moves_list[[i]] <- apply_check_all_true_match(data_moves_list[[i]], lookup_tables[[i]])
}

```

(make correct moves too)

```{r}
# Function to check if string is found in correct_moves_list
check_string_in_correct_moves <- function(string, correct_moves_df) {
  if (is.na(string) || string == "") {
    return("incorr")
  }
  
  if (any(correct_moves_df == string)) {
    return("corr")
  } else {
    return("incorr")
  }
}

# Function to apply the check_string_in_correct_moves function to a single data frame
apply_check_string_in_correct_moves <- function(df, correct_moves_df) {
  df %>%
    rowwise() %>%
    mutate(move_corr = case_when(
      Construct_Action_action_cd == "c" ~ check_string_in_correct_moves(string, correct_moves_df),
      Construct_Action_action_cd %in% c("d", "f") ~ "back",
      TRUE ~ NA_character_
    )) %>%
    ungroup()
}

# Apply the function to each pair of dataframes in the lists
for (i in 1:length(data_moves_list)) {
  data_moves_list[[i]] <- apply_check_string_in_correct_moves(data_moves_list[[i]], correct_moves_list[[i]])
}
```

```{r}
# Function to normalize New_Action_Number for each participant
normalize_action_numbers <- function(df) {
  df %>%
    group_by(ID_id) %>%
    mutate(Normalized_Action_Number = (New_Action_Number - min(New_Action_Number)) / (max(New_Action_Number) - min(New_Action_Number))) %>%
    ungroup()
}

# Apply the normalization function to each dataframe in the list
data_moves_list_normalized <- lapply(data_moves_list, normalize_action_numbers)

# Plot the normalized data for all dataframes in the list
for (i in seq_along(data_moves_list_normalized)) {
  print(
    ggplot(data_moves_list_normalized[[i]], aes(x = Normalized_Action_Number, y = ID_id, color = move_corr)) +
      geom_point(size = 3) +
      scale_color_manual(values = c("yellow", "green", "red")) +
      labs(title = paste("Participants' Moves: Correct vs Incorrect (Normalized) - Model", i),
           x = "Normalized Move",
           y = "Participant") +
      theme_minimal()
  )
}

# Filter out rows with move_corr == "back"
data_moves_list_filtered <- lapply(data_moves_list_normalized, function(df) df %>% filter(move_corr != "back"))

# Plot the normalized data for all dataframes in the list and save the images
for (i in seq_along(data_moves_list_filtered)) {
  p <- ggplot(data_moves_list_filtered[[i]], aes(x = Normalized_Action_Number, y = ID_id, color = move_corr)) +
    geom_point(size = 3) +
    scale_color_manual(values = c("green", "red")) +
    labs(title = paste("Participants' Moves: Correct vs Incorrect (Normalized) - Model", i),
         x = "Normalized Move",
         y = "Participant") +
    theme_minimal()
  
  ggsave(filename = paste0("trees/moves_corr_model_", i, ".png"), plot = p)
}
```

NOW WE START MAKING TREES 1.
First we want another column which tells us which blocks are mentioned in each construction, gives us another way of saying how many blocks are in each construction.
This would be hard to do with just moves as several moves can still be the same construction...

```{r}

# Function to extract and concatenate blocks
extract_blocks <- function(string) {
  # Extract all occurrences of the specified blocks within longer strings
  blocks <- str_extract_all(string, "(bl|bs|yl|ys|gs|gl|rl|rs)")[[1]]
  # Ensure the blocks are unique
  unique_blocks <- unique(blocks)
  # Sort the blocks alphabetically
  sorted_blocks <- sort(unique_blocks)
  # Concatenate the blocks into a single string, separated by underscores
  paste(sorted_blocks, collapse = "_")
}

# Apply the function to each dataframe in the list
data_moves_list <- lapply(data_moves_list, function(df) {
  df %>%
    mutate(blocks_in = sapply(concatenated_moves, extract_blocks))
})



```

this gives us the node from -- node to, + gets rid of extra moves.
i.e. if they added several blocks at once, now we just have the final row of what they've added + it includes the blocks that were in BEFORE the first part of the move (node from) and the blocks that were in THE LAST part of the move (node to)

```{r}
# Create a function to determine the direction of the edge
determine_direction <- function(from, to) {
  from_length <- length(strsplit(from, ",")[[1]])
  to_length <- length(strsplit(to, ",")[[1]])
  
  if (from == "0" && to != "0") {
    return("positive")
  } else if (to == "0") {
    return("negative")
  } else if (to_length > from_length) {
    return("positive")
  } else {
    return("negative")
  }
}

data_moves_list <- lapply(data_moves_list, function(df) {
  
  
  
  df %>%
    arrange(ID_id, New_Action_Number) %>%
    mutate(node_to = state,
           node_from = lag(state, default = "0")) %>%
    mutate(node_from = ifelse(New_Action_Number == 1, "0", node_from)) %>%
    group_by(ID_id, New_Action_Number) %>%
    mutate(node_from = first(node_from[move_number == min(move_number)]),
           node_to = first(node_to[move_number == max(move_number)])) %>%
    filter(move_number == max(move_number)) %>%
    ungroup() %>%
    mutate(blocks_num = str_count(blocks_in, "_") + 1) %>%
    mutate(direction = mapply(determine_direction, node_from, node_to)) %>%
    group_by(node_from, node_to) %>%
    mutate(frequency = n()) %>%
    ungroup()
})
```

sort nodes so same node (same moves but in different order) is seen

```{r}
# Define the function to sort the numbers within each node string
sort_node <- function(node) {
  sorted_numbers <- sort(as.numeric(unlist(strsplit(node, ","))))
  return(paste(sorted_numbers, collapse = ","))
}

# Apply the sorting function to all data frames in the list
data_moves_list <- lapply(data_moves_list, function(df) {
  df %>%
    mutate(node_from = sapply(node_from, sort_node),
           node_to = sapply(node_to, sort_node),
           state = sapply(state, sort_node))
})
```

I think we are ready to make trees!
First we can make individual trees for each participant based on main files, then we can make files with just distinct moves, to make overall trees with frequency...
make individual graphs

```{r}

# Define the function to create and plot the combined network graph for each participant
create_combined_network_graph <- function(data, highlight_nodes, highlight_edges, participant_id, model_name) {
  # Create a graph object using node_from and node_to columns for all data
  g <- graph_from_data_frame(d = data %>% select(node_from, node_to, direction, match, blocks_num, New_Action_Number, frequency), directed = TRUE)
  
  # Set node attributes
  V(g)$color <- ifelse(V(g)$name %in% data$node_to[data$match], "green", "yellow")
   # Override specific nodes to green
  specific_nodes <- c("1,3,5,7", "0")  # Replace with your actual node names
  V(g)$color[V(g)$name %in% specific_nodes] <- "green"
  V(g)$level <- sapply(V(g)$name, function(x) {
    if (x %in% data$node_to) {
      data$blocks_num[data$node_to == x][1]
    } else {
      NA
    }
  })
  
  # Set node labels to display block number
  V(g)$label <- sapply(V(g)$name, function(x) {
    if (x %in% data$node_to) {
      paste("Block", data$blocks_num[data$node_to == x][1])
    } else {
      NA
    }
  })
  
  # Identify the first node and include "0" in its label
  first_node <- data$node_from[1]
  if (!is.na(V(g)$label[V(g)$name == first_node])) {
    V(g)$label[V(g)$name == first_node] <- paste("0", V(g)$label[V(g)$name == first_node], sep = ", ")
  } else {
    V(g)$label[V(g)$name == first_node] <- "0"
  }
  
  # Set edge attributes
  E(g)$color <- "grey"
  E(g)$width <- data$frequency
  
  # Highlight edges
  edge_list <- paste(data$node_from, data$node_to)
  highlight_edge_list <- paste(highlight_edges$node_from, highlight_edges$node_to)
  E(g)$color <- ifelse(edge_list %in% highlight_edge_list, "red", E(g)$color)
  
  # Create a layout with the sugiyama algorithm
  layout <- layout_with_sugiyama(g)$layout
  layout <- as.data.frame(layout)
  colnames(layout) <- c("x", "y")
  layout$name <- V(g)$name
  
  # Adjust the y positions based on blocks_num and invert them
  layout$y <- -V(g)$level
  
  #Manually adjust the x positions to spread nodes horizontally
  unique_x <- unique(layout$x)
  spacing <- seq(from = min(unique_x), to = max(unique_x), length.out = length(unique_x))
  layout$x <- spacing[match(layout$x, unique_x)]
  #layout$x <- layout$x * 2  # Adjust this multiplier to spread nodes more
  #layout$x <- jitter(layout$x, amount = 2)
  
  # Plot the graph using ggraph with the adjusted layout
  p <- ggraph(g, layout = layout) + 
    geom_edge_link(aes(colour = color, width = width, label = frequency), arrow = arrow(length = unit(5, 'mm')), end_cap = circle(6, 'mm')) +
    geom_node_point(aes(color = color), size = 15) +
    geom_node_point(data = layout %>% filter(name %in% highlight_nodes), aes(x = x, y = y), color = "red", size = 17, shape = 21, stroke = 2) +
    scale_color_identity() +
    scale_edge_color_manual(values = c("grey", "red")) +  # Explicitly define edge colors
    theme_void() +
    ggtitle(paste("Combined Network Graph for Participant", participant_id, "in Model", model_name)) +
    guides(color = FALSE, edge_color = FALSE, edge_width = FALSE)
  
  # Save the plot as a PNG file in the "trees" folder
  file_name <- paste0("trees/highlighted_network_graph_", model_name, "_", participant_id, ".png")
  ggsave(file_name, plot = p, width = 32, height = 24)
}

# Process each data frame in the list
for (model_name in names(data_moves_list)) {
  df <- data_moves_list[[model_name]]
  
  # Get unique participant IDs
  participant_ids <- unique(df$ID_id)
  
  # Create and save combined network graphs for each participant
  for (participant_id in participant_ids) {
    filtered_data <- df %>% filter(ID_id == participant_id)
    highlight_nodes <- filtered_data$state
    highlight_edges <- filtered_data %>% select(node_from, node_to)
    
    create_combined_network_graph(df, highlight_nodes, highlight_edges, participant_id, model_name)
  }
}
```

Now we can make a tree of all the moves together for each model.
To do this we remove any duplicate moves and keep frequency of each move

And then use this code to make combined graph for each model

```{r}

# Define the function to create and plot the combined network graph without highlights
create_combined_graph <- function(data, model_name) {
  # Create a graph object using node_from and node_to columns for all data
  g <- graph_from_data_frame(d = data %>% select(node_from, node_to, direction, match, blocks_num, New_Action_Number, frequency), directed = TRUE)
  
  # Set node attributes
  V(g)$color <- ifelse(V(g)$name %in% data$node_to[data$match], "green", "yellow")
  V(g)$level <- sapply(V(g)$name, function(x) {
    if (x %in% data$node_to) {
      data$blocks_num[data$node_to == x][1]
    } else {
      NA
    }
  })
  # Set node labels to display block number
  V(g)$label <- sapply(V(g)$name, function(x) {
    if (x %in% data$node_to) {
      paste("Block", data$blocks_num[data$node_to == x][1])
    } else {
      NA
    }
  })
  
  # Identify the first node and include "0" in its label
  first_node <- data$node_from[1]
  if (!is.na(V(g)$label[V(g)$name == first_node])) {
    V(g)$label[V(g)$name == first_node] <- paste("0", V(g)$label[V(g)$name == first_node], sep = ", ")
  } else {
    V(g)$label[V(g)$name == first_node] <- "0"
  }
  
  # Set edge attributes
  E(g)$color <- ifelse(data$direction == "positive", "darkturquoise", "brown1")
  E(g)$width <- data$frequency
  
  # Create a layout with the sugiyama algorithm
  layout <- layout_with_sugiyama(g)$layout
  layout <- as.data.frame(layout)
  colnames(layout) <- c("x", "y")
  layout$name <- V(g)$name
  
  # Adjust the y positions based on blocks_num and invert them
  layout$y <- -V(g)$level
  
  # Manually adjust the x positions to spread nodes horizontally
   unique_x <- unique(layout$x)
  spacing <- seq(from = min(unique_x), to = max(unique_x), length.out = length(unique_x))
  layout$x <- spacing[match(layout$x, unique_x)]
  
  # Plot the graph using ggraph with the adjusted layout
  p <- ggraph(g, layout = layout) + 
    geom_edge_link(aes(colour = I(color), width = width, label = frequency), arrow = arrow(length = unit(5, 'mm')), end_cap = circle(6, 'mm')) +
    geom_node_point(aes(color = color), size = 15) +
    scale_color_identity() +
    theme_void() +
    ggtitle(paste("Combined Network Graph for Model", model_name)) +
    guides(color = FALSE, edge_color = FALSE, edge_width = FALSE)
  
  # Save the plot as a PNG file in the "trees" folder
  file_name <- paste0("trees/combined_network_graph_", model_name, ".png")
  ggsave(file_name, plot = p, width = 32, height = 24)
}

# Process each data frame in the list
for (model_name in names(data_moves_list)) {
  df <- data_moves_list[[model_name]]
  

  # Create and save the combined network graph without highlights
  create_combined_graph(df, model_name)
}
```

```{r}
# Define the function to create and plot the combined network graph for each participant
create_combined_network_graph <- function(data, highlight_nodes, highlight_edges, participant_id, model_name) {
  # Create a graph object using node_from and node_to columns for all data
  g <- graph_from_data_frame(d = data %>% select(node_from, node_to, direction, match, blocks_num, New_Action_Number, frequency), directed = TRUE)
  
  # Set node attributes
  V(g)$color <- ifelse(V(g)$name %in% data$node_to[data$match], "green", "yellow")
  V(g)$level <- sapply(V(g)$name, function(x) {
    if (x %in% data$node_to) {
      data$blocks_num[data$node_to == x][1]
    } else {
      NA
    }
  })
  
  # Print node attributes for debugging
  print(data.frame(name = V(g)$name, color = V(g)$color, level = V(g)$level))
  
  # Set node labels to display block number
  V(g)$label <- sapply(V(g)$name, function(x) {
    if (x %in% data$node_to) {
      paste("Block", data$blocks_num[data$node_to == x][1])
    } else {
      NA
    }
  })
  
  # Identify the first node and include "0" in its label
  first_node <- data$node_from[1]
  if (!is.na(V(g)$label[V(g)$name == first_node])) {
    V(g)$label[V(g)$name == first_node] <- paste("0", V(g)$label[V(g)$name == first_node], sep = ", ")
  } else {
    V(g)$label[V(g)$name == first_node] <- "0"
  }
  
  # Print node labels for debugging
  print(data.frame(name = V(g)$name, label = V(g)$label))
  
  # Set edge attributes
  E(g)$color <- "grey"
  E(g)$width <- data$frequency
  
  # Highlight edges
  edge_list <- paste(data$node_from, data$node_to)
  highlight_edge_list <- paste(highlight_edges$node_from, highlight_edges$node_to)
  E(g)$color <- ifelse(edge_list %in% highlight_edge_list, "red", E(g)$color)
  
  # Create a layout with the sugiyama algorithm
  layout <- layout_with_sugiyama(g)$layout
  layout <- as.data.frame(layout)
  colnames(layout) <- c("x", "y")
  layout$name <- V(g)$name
  
  # Adjust the y positions based on blocks_num and invert them
  layout$y <- -V(g)$level
  
  #Manually adjust the x positions to spread nodes horizontally
  unique_x <- unique(layout$x)
  spacing <- seq(from = min(unique_x), to = max(unique_x), length.out = length(unique_x))
  layout$x <- spacing[match(layout$x, unique_x)]
  #layout$x <- layout$x * 2  # Adjust this multiplier to spread nodes more
  #layout$x <- jitter(layout$x, amount = 2)
  
  # Print layout for debugging
  print(layout)
  
  # Plot the graph using ggraph with the adjusted layout
  p <- ggraph(g, layout = layout) + 
    geom_edge_link(aes(colour = color, width = width, label = frequency), arrow = arrow(length = unit(5, 'mm')), end_cap = circle(6, 'mm')) +
    geom_node_point(aes(color = color), size = 15) +
    geom_node_point(data = layout %>% filter(name %in% highlight_nodes), aes(x = x, y = y), color = "red", size = 17, shape = 21, stroke = 2) +
    scale_color_identity() +
    scale_edge_color_manual(values = c("grey", "red")) +  # Explicitly define edge colors
    theme_void() +
    ggtitle(paste("Combined Network Graph for Participant", participant_id, "in Model", model_name)) +
    guides(color = FALSE, edge_color = FALSE, edge_width = FALSE)
  
  # Save the plot as a PNG file in the "trees" folder
  file_name <- paste0("trees/highlighted_network_graph_", model_name, "_", participant_id, ".png")
  ggsave(file_name, plot = p, width = 32, height = 24)
}

# Process each data frame in the list
for (model_name in names(data_moves_list)) {
  df <- data_moves_list[[model_name]]
  
  # Get unique participant IDs
  participant_ids <- unique(df$ID_id)
  
  # Create and save combined network graphs for each participant
  for (participant_id in participant_ids) {
    filtered_data <- df %>% filter(ID_id == participant_id)
    highlight_nodes <- filtered_data$state
    highlight_edges <- filtered_data %>% select(node_from, node_to)
    
    create_combined_network_graph(df, highlight_nodes, highlight_edges, participant_id, model_name)
  }
}
```


